1. uvm_config_db
  
  uvm_config_db #(T)::set(uvm_component cntxt, string instance_path, string field_name, T value);
  when multiple set are done in the build phase, the 1st one takes effect while other set are ignored
  when multiple set are done outside the build phase, the last one takes effect

  uvm_config_db #(T)::get(uvm_component cntxt, string instance_path, string field_name, T value);

2. Override
  set_type_override_by_type ( uvm_object_wrapper original_type,
                            uvm_object_wrapper override_type,
                            bit replace=1);

  set_type_override_by_name ( string original_type_name,
                            string override_type_name,
                            bit replace=1);

  // Override a type within a particular instance
  set_inst_override_by_type (uvm_object_wrapper original_type,
                           uvm_object_wrapper override_type,
                           string full_inst_path);

  set_inst_override_by_name (string original_type_name,
                           string override_type_name,
                           string full_inst_path);
  
  factory.set_type_override_by_type(original::get_type(), override::get_type());
  original_class::type_id::set_type_override(override_class::get_type());

3. factory

  class uvm_component_registry #(type T = uvm_component, string name) extends uvm_object_wrapper;
    local static uvm_component_registry #(T, name) this_t = get;

    static function this_t get();
      if (this_t == null) begin
        this_t = new;
        factory.register(this_t);
      end
      return this_t;
    endfunction
  endclass : uvm_component_registry
    
  class component extends uvm_component;
    typedef uvm_component_registry #(component, "component")  type_id;

    static function type_id get_type();
      return type_id::get();
    endfunction

    function string get_type_Name();
      return "component";
    endfunction
  endclass
4. TLM connection
  analysis port  - uvm_analysis_port #()
    analysis_port require an implementation of write to be connected to it
    port.get_provided_to(list[$])
    when it calls port.write() it goes through the list and calls write method on all the connected exports
    analysis_port are generally used to move up the testbench hierarchy (monitor to agent)
  analysis export- uvm_analysis_export #()
    analysis_eport are connected to analysis_export or analysis_imp. 
    mon.port.connect(comp.port);
  analysis imp   - uvm_analysis_imp #()
    analysis_imp is the one that calls the final write method
    `uvm_analysis_imp_decl(inport)
    uvm_analysis_imp_inport inport#()
    function void write_inport()
    mon.port.connect(scbd.port);

  analysis fifo  - uvm_tlm_analysis_fifo #()
    mon.port.connect(scbd.port.analysis_export)

  if synchronization is required than generally use uvm_tlm_analysis_fifo #()
  if streams or channels are not dependent on each other than use uvm_analysis_imp #()

  uvm_subscriber has a built-in write method. The coverage_monitor can extend from the uvm_subscriber #() and implement the write function
  driver.seq_item_port.connect(sequencer.seq_item_export);
  driver.rsp_port.connect(sequencer.rsp_export);

  functionv void write (transcation)

7. sequence -> sequencer -> driver mechanism
  - class driver extends uvm_driver #(req, rsp) OR class driver extends uvm_driver#(req) in this case same sequence item is used for request and response
  Sequence:
    - The driver should set set_id_info to the response item when returning a response so that sequencer knows which sequence the response is for
    - grab and lock methods. They take control over the sequence - sequencer - driver channel
    - sequence.start(sequencer)
    - create sequence
    - 0start_item(item) -> this call blocks until the sequencer grants the channel to the sequence
    - finish_item(item) -> this call blocks until the driver is done with its execution. no simulation time must be consumed between start_item and finish_item
    - get_response() -> if the sequence is expecting a response it needs to wait for the response
  Driver:
    - get_next_item(item) -> blocks until a sequence item is available in the sequencer FIFO
    - try_next_item(item) -> non-blocking call to check if a sequence item is available in the sequencer FIFO
    - item_done(rsp_item) -> non-blocking item_done indicating the handshake is done. if it is passed without any arguments it means there is no rsp sent.
    - peek()              -> similar to get_next_item
    - get()               -> similar to get_next_item
    - put()               -> puts a response in the sequencer FIFO to send it back to the sequence

    get_next_item and item_done handshaking
    - #0 blocking call driver.get_next_item(item), wait for seq.start_item(item)
    - #5 seq.start_item(item)
    - #5 driver.get_next_item(item) unblocks
    - #5 blocking call seq.finish_item(item), waits for driver.item_done()
    - #10 driver.item_done() is called unblocking seq.finish_item(item)
    - #10 process next sequence item if any

    get and put handshaking
    - #0 blocking call driver.get(item), wait for seq.start_item(item)
    - #5 seq.start_item(item)
    - #5 driver.get(item) unblocks
    - #5 seq.finish_item(item) unblocks
    - #10 seq.get_response() is blocked, waiting for a driver.put(rsp)
    - #15 driver.put(rsp), unblocks sequence, rsp.set_id_info(req_item)
    - #15 process next sequence if any

8. virtual sequence
  It is a base sequence that contains other sub-sequences which can be start on multiple sequencers.
  The execution of the sequences can be hierarchical, parallel or in random order or user defined way

  // Virtual sequence
  class top_vseq_base extends uvm_sequence #(uvm_sequence_item);
    `uvm_object_utils(top_vseq_base)
    uvm_sequencer #(a_seq_item) A1;
    uvm_sequencer #(a_seq_item) A2;
    uvm_sequencer #(b_seq_item) B;
    uvm_sequencer #(c_seq_item) C;
    function new(string name = "top_vseq_base");
    super.new(name);
    endfunction
  endclass: top_vseq_base

  // uvm_test_top
  class test_top_base extends uvm_test;
    `uvm_component_utils(test_top_base)
    env_top m_env;
    function new(string name = "test_top_base", uvm_component parent = null);
    super.new(name, parent);
    endfunction
    function void build_phase(uvm_phase phase);
    m_env = env_top::type_id::create("m_env", this);
    endfunction: build_phase
    // Method to initialize the virtual sequence handles
    function void init_vseq(top_vseq_base vseq);
    vseq.A1 = m_env.m_env_1.m_agent_a.m_sequencer;
    vseq.C = m_env.m_env_1.m_agent_c.m_sequencer;
    vseq.A2 = m_env.m_env_2.m_agent_a.m_sequencer;
    vseq.B = m_env.m_env_2.m_agent_b.m_sequencer;
    endfunction: init_vseq
  endclass: test_top_base

9. virtual sequencer
  it is a normal sequencer that it not connected to any driver and contains handle to all the target sequencers.
  generally, virtual sequences are extended from a base class which does all the handle assignment to the virtual sequencer.
10. ral block

  build_phase();
  ral = ral_block::type_id::create("", this);
  ral.build();
  ral.lock_model();

  adapter = m_reg2axi_adapter::type_id::create("",this);
  predictor = uvm_reg_predictor #(transaction)::type_id::create("",this);
  predictor.adapter = m_reg2axi_adapter
  predictor.default_map = ral.default_map;

  connect_phase();
    ral.default_map.set_sequencer(<sequencer>, <adapter>);
    ral.default_map.set_auto_predict(1);
    agent.mon.port.connect(predictor.bus_in);
